/**
* Parse Stripe-Signature header and store custom object
* 
* @input requestObj : Object
* @output responseCode : Number
*/
importPackage( dw.system );

var Mac = require('dw/crypto/Mac');
var Encoding = require('dw/crypto/Encoding');
var Transaction = require('dw/system/Transaction');

var StripeHelper = require('*/cartridge/scripts/stripeHelper');

function execute(args : PipelineDictionary) : Number {
	if (!webhook(args)) {
		args.responseCode = 500;
		return PIPELET_NEXT;	
	}
	args.responseCode = 200;
	return PIPELET_NEXT;
	
};

/**
 * Parse Stripe-Signature header and get an object with timestamp and key/value pairs of signatures
 * @param header - Stripe-Signature header
 * @param scheme - Stripe-Signature true key
 * @returns {*} - Object with timestamp and key/value pairs of signatures
 * @private
 */
 
function _parseHeader(header, scheme) {
    if (typeof header !== 'string') {
        return null;
    }

    return header.split(',').reduce(function(accum, item) {
        var kv = item.split('=');

        if (kv[0] === 't') {
            accum.timestamp = kv[1];
        }

        if (kv[0] === scheme) {
            accum.signatures.push(kv[1]);
        }

        return accum;
    }, {
        timestamp: -1,
        signatures: []
    });
}

/**
 * Encrypt payload and secret key
 * @param payload
 * @param secret
 * @returns {*} encoded string
 * @private
 */

function _computeSignature(payload, secret) {
    var HMAC = new Mac(Mac.HMAC_SHA_256);
    return Encoding.toHex(HMAC.digest(payload,secret));
}

function webhook(args) {
	    const DEFAULT_TOLERANCE = 300,
    	EXPECTED_SCHEME = 'v1';
    var endpointSecret = dw.system.Site.current.preferences.custom.stripeWebhookSigningSecret,
    	payload = args.requestObj.httpParameterMap.requestBodyAsString,
    	stripeSignature = args.requestObj.httpHeaders['stripe-signature'],
    	tolerance = DEFAULT_TOLERANCE;
    
	try {
	    var details = _parseHeader(stripeSignature, EXPECTED_SCHEME);
	    if (!details || details.timestamp === -1) {
	    	response.setStatus(500);
	    	return false;
	    }
	
	    if (!details.signatures.length) {
	    	response.setStatus(500);
	    	return false;
	    }
	
	    var expectedSignature = _computeSignature(details.timestamp + '.' + payload, endpointSecret);
	    var signatureFound = details.signatures.indexOf(expectedSignature);
	
	    if (signatureFound === -1) {
	    	response.setStatus(500);
	    	return false;
	    }
	
	    var timestampAge = Math.floor(Date.now() / 1000) - details.timestamp;
	
	    if (tolerance > 0 && timestampAge > tolerance) {
	    	response.setStatus(500);
	    	return false;
	    }

	    var success = Transaction.wrap(function () {
			var json = JSON.parse(request.httpParameterMap.getRequestBodyAsString());
			if (dw.object.CustomObjectMgr.getCustomObject(StripeHelper.GetCustomObjectNotificationType(), json.id) == null) {
				if (StripeHelper.IsWebHookStatusValid(json.type) && StripeHelper.IsSourceHasValidType(json)) {
					var stripeNotification = dw.object.CustomObjectMgr.createCustomObject(StripeHelper.GetCustomObjectNotificationType(), json.id);
					stripeNotification.custom.dateCreated = json.created;
					stripeNotification.custom.stripeObjectId = json.data.object.id;
					stripeNotification.custom.stripeObjectType = json.data.object.object;
					stripeNotification.custom.amount = json.data.object.amount;
					stripeNotification.custom.currency = json.data.object.currency;
					stripeNotification.custom.stripeSourceId = json.data.object.object == 'source' ? json.data.object.id : (json.data.object.object == 'charge' ? json.data.object.source.id : '');
					stripeNotification.custom.livemode = json.livemode;
					stripeNotification.custom.stripeType = json.type;
					stripeNotification.custom.orderId = json.data.object.metadata.orderId ? json.data.object.metadata.orderId : (json.data.object.source.metadata.orderId ? json.data.object.source.metadata.orderId : '');

					switch(json.type) {
					case 'source.chargeable':
					case 'source.canceled':
					case 'source.failed':
					case 'charge.failed':
					case 'charge.succeeded':
					case 'charge.pending':
						stripeNotification.custom.processingStatus = 'PROCESS';
						break;
					default:
						stripeNotification.custom.processingStatus = 'UNKNOWN';
					}

					stripeNotification.custom.stripeWebhookData = request.httpParameterMap.getRequestBodyAsString();
				}
				return true;
			} else {
				return false;
			}
	    });
	    if (!success) {
			response.setStatus(500);
			return false;
	    }
	} catch (e) {
		dw.system.Logger.error(e);
		response.setStatus(500);
		return false;
	}
	
	response.setStatus(200);
	return true;
}

module.exports = {
	'execute': execute,
	'webhook': webhook
}